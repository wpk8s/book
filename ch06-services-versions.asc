[[ch06-services-versions]]
== Services versions

I'm really glad you've made it until now. We still have a few steps to
achieve a production grade concept to deploy WordPress.

In this chapter we are going to detail about versions of services used,
that is for WordPress container and MariaDB.

MicroK8s is a Kubernetes distribution intended to self upgrade, and as
long as external addons are used at minimum, maintenance over it is
minimal.

It's normal we must take care of the operating system updates, and I will
give you some tricks for automating upgrades and schedule safe restarts if
needed.

Our discussed extra addon until now, **cert-manager**, it's upgrade can be
done, by applying the main remote configuration on each new tag, and to be
aware of that, we can use different ways, like subscribing in Github to
be notified by each new release of the project.

But let's start with our **WordPress** services management.

=== Locking container versions

I'll bring back again the full recipe of a WordPress website
and we will *talk* on every important part of it.

.https://j.mp/3q0UdLp[kustomization.yml]
[source,yaml,linenums]
----
---
secretGenerator:
# Saving the password in clear text
# must not be done for public, production facing
# websites.
- name: mysql-pass
  literals:
  - password=password123
resources:
  - mysql-statefulset.yaml
  - wordpress-statefulset.yaml
----

This is our start, our Kustomization file.

We don't have any mention about a service version in it, but there is one critical
thing. We stored a clear text password in it. We must not do this ever for
production, public facing websites. It was simply easy to exemplify for a
private experiment short lived that should be removed!

What would be best practices to handle secrets for our websites? There are lots
of options and opinions on how to do this. I take an easy approach.

I use a passwords application to save them. I use https://keepass.info[KeePass]
and any similar solution, cloud based also should be fine.

Once I'm creating a new strong password, save it organized well, in case of
KeePass, I use a dedicated database file for projects, I'm creating using
`kubectl` the secret with the password.

Let's create a configuration template and a bash script to automate creation
and update of a secret. You will be able to reuse this anytime you
want to create a new secret or update an existing one. Make a new directory
to store this files.

We will also extend our secret to set a custom user name and password for best
security practices, avoiding using root user to connect to the database.

.safe-password-manager.yml.tmpl
[source,yaml,linenums]
----
---
apiVersion: v1
kind: Secret
metadata:
  name: SECRET_NAME
type: Opaque
data:
  # You can include additional key value pairs as you do with Opaque Secrets
  root_password: ROOT_PASSWORD
  username: USER_NAME
  password: USER_PASSWORD
----

.safe-password-manager.sh
[source,bash,linenums]
----
#!/usr/bin/env bash
echo -n "Please enter a secret password name: "
read SECRET_NAME

echo -n "Please enter the root password: "
read -p ROOT_PASSWORD

echo -n "Please enter the DB username: "
read -p USER_NAME

echo -n "Please enter the user password: "
read -p USER_PASSWORD

echo -e "\n"

sed "s/SECRET_NAME/$SECRET_NAME/g" \
  safe-password-manager.yml.tmpl | \
  sed "s/ROOT_PASSWORD/`echo $ROOT_PASSWORD|base64`/g" - | \
  sed "s/USER_NAME/`echo $USER_NAME|base64`/g" - | \
  sed "s/USER_PASSWORD/`echo $USER_PASSWORD|base64`/g" - | \
  microk8s.kubectl apply -f -
----

To create a new password now, just run:
`bash safe-password-manager.sh`
enter the secret name and after the password.

The output should look like:

[source,text]
----
madalin@devserver:~/secret-password-manager$ bash safe-password-manager.sh
Please enter a secret password name: new-secret-password
Please enter the password:

secret/new-secret-password created
----

Next, let's go through the MariaDB service.

.https://j.mp/3cRFHSq[mysql-statefulset.yml]
[source,yaml,linenums]
----
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress-mysql
  labels:
    app: wordpress
spec:
  ports:
    - port: 3306
  selector:
    app: wordpress
    tier: mysql
  clusterIP: None
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: wordpress-mysql
  labels:
    app: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: mysql
  serviceName: wordpress-mysql
  template:
    metadata:
      labels:
        app: wordpress
        tier: mysql
    spec:
      containers:
      - image: mariadb:10.5
        name: mysql
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: wordpress-mysql
          mountPath: /var/lib/mysql
  volumeClaimTemplates:
  - metadata:
      name: wordpress-mysql
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 10Gi
----

We have created MariaDB as a stateful service.

Kubernetes defines a list of
https://kubernetes.io/docs/concepts/workloads/controllers/[**Workload Resources**]
which include the above **StatefulSet** used by me. Running MariaDB or any other
database, requires that each instance has a particular configuration if
high availability is desired for databases, and the storage is dedicated to
one single instance running. On the opposite side, is the **ReplicaSet**, preferred
to be deployed using **Deployments** and are intended to be used in configurations
where fast replicas need to be started. We will detail them in the next chapter,
**High Availability**, which requires us to move from classic WordPress usage, that
allows Core, Plugins, Themes, and uploads usage on a volume, towards ReplicaSets,
allowing us to start as many replicas of WordPress containers in the limit
of hardware resources we make available.

To lock the MariaDB version we are using, we only need to set the desired value
in `- image: mariadb:10.5`. MariaDB uses a 3 numbers versioning scheme, popular
among open source software, usually named https://semver.org/[Semantic Versioning],
which defines for `X.Y.Z`:

* **X** is the MAJOR, very critical number, and a project might not be able
  to change from it easy.
* **Y** is the MINOR, number which makes us understand that new features have been
  added, possible performance enhancements.
* **Z** is the PATCH, the most important number you should care about for the
  database of a WordPress database. This number means that critical security or
  bug fixes have been done and you should upgrade as soon as possible.

I do not recommend upgrading a MAJOR for MariaDB or MySQL on an existing
WordPress website just for the bravery of stating you have upgraded. Stick to
current recommended MAJOR for the WordPress version you are using until the
community is stating for a few good months that all is working fine on a new
MAJOR.

At the moment I wrote the book WordPress requirements where:

* PHP 7.4 or higher, core runs perfect on 8.0 visible faster, but plugins and themes,
  many are still not guaranteed to run on 8.x.
* MySQL 5.6 or MariaDB 10.1 or recent. This means MySQL 5.7 and any MariaDB 10.x
  included. Possible will work fine with MySQL 8.0 also.

So, how we ensure we use latest version without getting issues?

Our database stores it's data in a volume we have defined in the above recipe.

I do it this way, and it's the way I recommend doing it: make a database backup.
Avoid using a plugin based backup solution for database and use the command line
if you are confident or add a service like Adminer.

Method 1: command line.

Let's write a small script to backup a database. You will be able to use it for
all WordPress website you would host with MicroK8s, and not only WordPress, but
any MySQL/MariaDB based. We need the mysql/mariadb client installed locally, and
as we use Ubuntu as our host operating system, we can have it installed just by
running: `sudo apt update && sudo apt install -y mariadb-client`.

.databasebackup.sh
[source,bash,linenums]
----
#!/usr/bin/env bash
echo -n "Hostname: "
read HOSTNAME

echo -n "Username: "
read USERNAME

echo -n "Database: "
read DATABASE

# password will be asked actually by the command itself
mysqldump -h$HOSTNAME -u$USERNAME -p $DATABASE > $DATABASE-`date +"%s"`.sql
----

To get the HOSTNAME, run `microk8s.kubectl get service wpk8s-club-demo-mysql`
and it is the value under **CLUSTER-IP**.

If you have not saved your password (please try to save passwords in a
personal vault, for example KeePass), you can obtain it from the saved secrets:
`microk8s.kubectl get secrets | grep wpk8s-club-demo-mysql-pass`
to identify secret name with possible added hash;
`microk8s.kubectl get secret wpk8s-club-demo-mysql-pass-REPLACEHASH -ojson | jq -r ".data.password" | base64 --decode`.

Now you can run the script: `bash databasebackup.sh`. The sql dump will be named
like the database and current timestamp suffixed to it.

.https://j.mp/2MJJMNZ[wordpress-statefulset.yml]
[source,yaml,linenums]
----
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: wordpress
  labels:
    app: wordpress
spec:
  rules:
  - host: wordpress.k8s
    http:
      paths:
        - pathType: Prefix
          path: "/"
          backend:
            service:
              name: wordpress
              port:
                number: 80
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress
  labels:
    app: wordpress
spec:
  ports:
  - port: 80
    protocol: TCP
  selector:
    app: wordpress
    tier: frontend
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: wordpress
  labels:
    app: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  serviceName: wordpress
  template:
    metadata:
      labels:
        app: wordpress
        tier: frontend
    spec:
      initContainers:
      - name: init-mysql
        image: busybox
        command: ['sh', '-c', 'until nslookup wordpress-mysql; do echo waiting for mysql; sleep 2; done;']
      containers:
      - image: wordpress:5.6
        name: wordpress
        env:
        - name: WORDPRESS_DB_HOST
          value: wordpress-mysql
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 80
          name: wordpress
        volumeMounts:
        - name: wordpress
          mountPath: /var/www/html
  volumeClaimTemplates:
  - metadata:
      name: wordpress
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 10Gi
----

=== Upgrading services
