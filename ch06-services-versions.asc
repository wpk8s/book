[[ch06-services-versions]]
== Services versions

I'm really glad you've made it until now. We still have a few steps to
achieve a production grade concept to deploy WordPress.

In this chapter we are going to detail about versions of services used,
that is for WordPress container and MariaDB.

MicroK8s is a Kubernetes distribution intended to self upgrade, and as
long as external addons are used at minimum, maintenance over it is
minimal.

It's normal we must take care of the operating system updates, and I will
give you some tricks for automating upgrades and schedule safe restarts if
needed.

Our discussed extra addon until now, **cert-manager**, it's upgrade can be
done, by applying the main remote configuration on each new tag, and to be
aware of that, we can use different ways, like subscribing in Github to
be notified by each new release of the project.

But let's start with our **WordPress** services management.

=== Locking container versions

I'll bring back again the full recipe of a WordPress website
and we will *talk* on every important part of it.

.https://j.mp/3q0UdLp[kustomization.yml]
[source,yaml,linenums]
----
---
secretGenerator:
# Saving the password in clear text
# must not be done for public, production facing
# websites.
- name: mysql-pass
  literals:
  - password=password123
resources:
  - mysql-statefulset.yaml
  - wordpress-statefulset.yaml
----

This is our start, our Kustomization file.

We don't have any mention about a service version in it, but there is one critical
thing. We stored a clear text password in it. We must not do this ever for
production, public facing websites. It was simply easy to exemplify for a
private experiment short lived that should be removed!

What would be best practices to handle secrets for our websites? There are lots
of options and opinions on how to do this. I take an easy approach.

I use a passwords application to save them. I use https://keepass.info[KeePass]
and any similar solution, cloud based also should be fine.

Once I'm creating a new strong password, save it organized well, in case of
KeePass, I use a dedicated database file for projects, I'm creating using
`kubectl` the secret with the password.

Let's create a configuration template and a bash script to automate creation
and update of a secret. You will be able to reuse this anytime you
want to create a new secret or update an existing one. Make a new directory
to store this files.

We will also extend our secret to set a custom user name and password for best
security practices, avoiding using root user to connect to the database.

.safe-password-manager.yml.tmpl
[source,yaml,linenums]
----
---
apiVersion: v1
kind: Secret
metadata:
  name: SECRET_NAME
type: Opaque
data:
  # You can include additional key value pairs as you do with Opaque Secrets
  root_password: ROOT_PASSWORD
  username: USER_NAME
  password: USER_PASSWORD
----

.safe-password-manager.sh
[source,bash,linenums]
----
#!/usr/bin/env bash
echo -n "Please enter a secret password name: "
read SECRET_NAME

echo -n "Please enter the root password: "
read -p ROOT_PASSWORD

echo -n "Please enter the DB username: "
read -p USER_NAME

echo -n "Please enter the user password: "
read -p USER_PASSWORD

echo -e "\n"

sed "s/SECRET_NAME/$SECRET_NAME/g" \
  safe-password-manager.yml.tmpl | \
  sed "s/ROOT_PASSWORD/`echo $ROOT_PASSWORD|base64`/g" - | \
  sed "s/USER_NAME/`echo $USER_NAME|base64`/g" - | \
  sed "s/USER_PASSWORD/`echo $USER_PASSWORD|base64`/g" - | \
  microk8s.kubectl apply -f -
----

To create a new password now, just run:
`bash safe-password-manager.sh`
enter the secret name and after the password.

The output should look like:

[source,text]
----
madalin@devserver:~/secret-password-manager$ bash safe-password-manager.sh
Please enter a secret password name: new-secret-password
Please enter the password:

secret/new-secret-password created
----

Next, let's go through the MariaDB service.

.https://j.mp/3cRFHSq[mysql-statefulset.yml]
[source,yaml,linenums]
----
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress-mysql
  labels:
    app: wordpress
spec:
  ports:
    - port: 3306
  selector:
    app: wordpress
    tier: mysql
  clusterIP: None
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: wordpress-mysql
  labels:
    app: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: mysql
  serviceName: wordpress-mysql
  template:
    metadata:
      labels:
        app: wordpress
        tier: mysql
    spec:
      containers:
      - image: mariadb:10.5
        name: mysql
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: wordpress-mysql
          mountPath: /var/lib/mysql
  volumeClaimTemplates:
  - metadata:
      name: wordpress-mysql
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 10Gi
----

We have created MariaDB as a **Stateful** service.

Kubernetes defines a list of
https://kubernetes.io/docs/concepts/workloads/controllers/[**Workload Resources**]
which include the above **StatefulSet** used by me. Running MariaDB or any other
database, requires that each instance has a particular configuration if
high availability is desired for databases, and the storage is dedicated to
one single instance running. On the opposite side, is the **ReplicaSet**, preferred
to be configured using **Deployments** and are intended to be used in configurations
where multiple replicas need to be started. We will detail them in the next chapter,
**High Availability**, which requires us to move from classic WordPress usage, that
allows Core, Plugins, Themes, and uploads usage on a volume, towards ReplicaSets,
allowing us to start as many replicas of WordPress containers in the limit
of hardware resources we make available.

To lock the MariaDB version we are using, we only need to set the desired value
in `- image: mariadb:10.5`. MariaDB uses a 3 numbers versioning scheme, popular
among open source software, usually named https://semver.org/[Semantic Versioning],
which defines for `X.Y.Z`:

* **X** is the MAJOR, very critical number, and a project might not be able
  to change from it easy.
* **Y** is the MINOR, number which makes us understand that new features have been
  added, possible performance enhancements.
* **Z** is the PATCH, the most important number you should care about for the
  database of a WordPress database. This number means that critical security or
  bug fixes have been done and you should upgrade as soon as possible.

I do not recommend upgrading a MAJOR for MariaDB or MySQL on an existing
WordPress website just for the bravery of stating you have upgraded. Stick to
current recommended MAJOR for the WordPress version you are using until the
community is stating for a few good months that all is working fine on a new
MAJOR.

At the moment I wrote the book WordPress requirements where:

* PHP 7.4 or higher, core runs perfect on 8.0 visible faster, but plugins and themes,
  many are still not guaranteed to run on 8.x.
* MySQL 5.6 or MariaDB 10.1 or recent. This means MySQL 5.7 and any MariaDB 10.x
  included. Possible will work fine with MySQL 8.0 also.

So, how we ensure we use latest version without getting issues?

Our database stores it's data in a volume we have defined in the above recipe.

I do it this way, and it's the way I recommend doing it: make a database backup.
Avoid using a plugin based backup solution for database and use the command line
if you are confident or add a service like Adminer.

**Method 1: command line.**

Let's write a small script to backup a database. You will be able to use it for
all WordPress website you would host with MicroK8s, and not only WordPress, but
any MySQL/MariaDB based. We need the mysql/mariadb client installed locally, and
as we use Ubuntu as our host operating system, we can have it installed just by
running: `sudo apt update && sudo apt install -y mariadb-client`.

.databasebackup.sh
[source,bash,linenums]
----
#!/usr/bin/env bash
echo -n "Hostname: "
read HOSTNAME

echo -n "Username: "
read USERNAME

echo -n "Database: "
read DATABASE

# password will be asked actually by the command itself
mysqldump -h$HOSTNAME -u$USERNAME -p $DATABASE > $DATABASE-`date +"%s"`.sql
----

To get the HOSTNAME, run `microk8s.kubectl get service wpk8s-club-demo-mysql`
and it is the value under **CLUSTER-IP**. Replace `wpk8s-club-demo-mysql` with
the service name you set for the website.

If you have not saved your password (please try to save passwords in a
personal vault, for example KeePass), you can obtain it from the saved secrets:
`microk8s.kubectl get secrets | grep wpk8s-club-demo-mysql-pass`
to identify secret name with possible added hash;
`microk8s.kubectl get secret wpk8s-club-demo-mysql-pass-REPLACEHASH -ojson | jq -r ".data.password" | base64 --decode`.
Do not forget to replace `wpk8s-club-demo-mysql*` with what you used.

Now you can run the script: `bash databasebackup.sh`. The sql dump will be named
like the database and current timestamp suffixed to it. You can copy or move it
in a safe place.

**Method 2: add Adminer.**

Alternative we can add a database management script, which might help you for
other needs as well, especially if you are used with shared hosting where you
had easy access to phpMyAdmin.

TIP: You can use phpMyAdmin as an alternative to Adminer if you are very used to it.

In the same directory with our demo website's recipe, let's create an additional
yaml file, containing the deployment and service configuration for Adminer.

Replace `wpk8s-club-demo` with your naming used in the rest of configurations.

[source,yaml,linenums]
----
---
apiVersion: v1
kind: Service
metadata:
  name: wpk8s-club-demo-adminer
  labels:
    app: wpk8s-club-demo
spec:
  ports:
    - port: 8080
      protocol: TCP
  selector:
    app: wpk8s-club-demo
    tier: adminer
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wpk8s-club-demo-adminer
  labels:
    app: wpk8s-club-demo
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wpk8s-club-demo
      tier: adminer
  template:
    metadata:
      labels:
        app: wpk8s-club-demo
        tier: adminer
    spec:
      containers:
      - image: adminer:4.8.0
        name: adminer
        env:
        - name: ADMINER_DEFAULT_SERVER
          value: wpk8s-club-demo-mysql
        ports:
        - containerPort: 8080
----

Next, we will extract the **Ingress** configuration from `wordpress-statefulset.yml`,
and extend it

.ingress.yml
[source,yaml,linenums]
----
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: wpk8s-club-demo
  labels:
    app: wpk8s-club-demo
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/proxy-body-size: 10m
    nginx.ingress.kubernetes.io/server-alias: "www.demo.wpk8s.club"
spec:
  tls:
  - hosts:
    - demo.wpk8s.club
    - www.demo.wpk8s.club
    secretName: wpk8s-club-demo-tls
  rules:
  - host: demo.wpk8s.club
    http:
      paths:
        - pathType: Prefix
          path: "/"
          backend:
            service:
              name: wpk8s-club-demo
              port:
                number: 80
        - pathType: Prefix
          path: "/adminer"
          backend:
            service:
              name: wpk8s-club-demo-adminer
              port:
                number: 8080
----

We added in it just the new `/adminer` path, pointing to the new
Adminer service we dedicated for this website.

NOTE: In a cluster, you could actually dedicate an Adminer or phpMyAdmin
instance, on a domain/subdomain of choice, to support all hosted databases.
Alternative to separate databases, for common websites with less sensitive
data, you could even use one common database service. We will detail this
later, in a section related to saving resources to lower costs.

Edit `kustomization.yml` and add Adminer and the new Ingress configuration.

.kustomization.yml
[source,yaml,linenums]
----
---
secretGenerator:
- name: wpk8s-club-demo-mysql-pass
  literals:
  - password=wCpWU9plzMF1
resources:
  - mysql-statefulset.yml
  - wordpress-statefulset.yml
  - adminer-deployment.yml
  - ingress.yml
----

NOTE: It is best to keep order exactly how they would be needed to be applied,
as it will help you understand it better when you have to customize later.

Apply all new changes by running:
`microk8s.kubectl apply -k ./`

In your browser, open the website url and add `/adminer` at the end. Fill in the
user, password and hostname, in case it was not prefilled in, and start using
Adminer to backup, restore, alter the data.

Securing this path could be done in different ways.

* Nginx Ingress annotations to add user and password on the `/adminer` path.
I use this on shared Adminer service in a cluster.

* Comment the Adminer entry in the Ingress configuration and apply. It will
not serve from the Adminer backend service. It's easy and safe.

* Set replicas to 0 to the Adminer service.

I think I diverted a lot from versioning, by showing you how to backup the
database, I did not touch the WordPress files and the uploads as in current
configuration we have used, you are still able to use classic, in WordPress,
plugins to do that. Remember, your WordPress installation and your uploads are
in a volume, and as until now we have used the builtin Storage addon, you can find
all files in
`/var/snap/microk8s/common/default-storage/[extended-name-of-defined-volume`].
So, I would do either a full copy of the directory, using
`cp -r default-wpk8s-club-demo-wpk8s-club-demo-0-pvc-7a4ce87d-c20a-40bf-a308-ee1f80c84f10 filesbackup`
or archive them if storage is constrained
`tar czfv filesbackup.tar.gz default-wpk8s-club-demo-wpk8s-club-demo-0-pvc-7a4ce87d-c20a-40bf-a308-ee1f80c84f10`.

As you are controlling the host of the cluster, you could even install Midnight Commander
to have a **tui** application with a familiar interface to manage files.
`sudo apt install -y mc` to get it installed for you. Run `sudo mc` and enjoy. You need
root access to be able to access volumes files and make sure you don't alter permissions
or ownership of files and directories, **mc** has the option when copying or moving
to preserve files attributes as they are.

Let's go back to versioning.

In our `wordpress-statefulset.yml` we have defined `- image: wpk8s/wordpress:5.6.1`.
When a new image is available, all you need to do is to change the version and
apply. Yes, it's that simple only. But with this way using WordPress, what is
upgraded, is actually Apache HTTPD and PHP version. The official WordPress container
image on https://hub.docker.com[Docker Hub] comes with an init script that downloads
the WordPress version on the selected tag, puts files in the declared volume and
from that moment, WordPress is in control, just like you used it in shared hosting.
You are fine to set auto-updates for WordPress, for plugins and for themes as you
were used to do. An alternative, required for High Availability that enforces
a locked WordPress installation will be detailed in next chapter.

To experiment, change the version and apply:
`microk8s.kubectl apply -k ./` or
`microk8s.kubectl apply -f wordpress-statefulset.yml` will update only
configuration defined in it.

We can do this for MariaDB or MySQL service as well.

Let's make one single change in the `mysql-statefulset.yml` configuration, to support
upgrades. We must use https://mariadb.com/kb/en/mysql_upgrade/[MySQL Upgrade] script.
We will run the script in `postStart` option of the
https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks[lifecycle definition].

The containers section in the `mysql-statefulset.yml` configuration file needs to be
changed like the following example (make sure you use the names for your services,
replacing `wpk8s-club-demo` with what you used).

.mysql-statefulset.yml
[source,yaml,linenums]
----
#...
      containers:
      - image: mariadb:10.5.9
        name: mysql
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: wpk8s-club-demo-mysql-pass
              key: password
        ports:
        - containerPort: 3306
          name: mysql
        volumeMounts:
        - name: wpk8s-club-demo-mysql
          mountPath: /var/lib/mysql
        lifecycle:
          postStart:
            exec:
              command: ["/bin/sh", "-c", "sleep 15; mysql_upgrade"]
#...
----

We upgraded from 10.5.8 to 10.5.9 MariaDB and we added the postStart hook
in the lifecycle entry. The `sleep 15` will grant the service to really start.
The postStart hook runs asynchronous to containers entrypoint, so MariaDB or
MySQL might not be ready to accept connections yet. Sleep will grant decent
amount of time for it to be ready and as years have proved, the mysql_upgrade
script will do it's job almost all the time. I do say almost, as this is why
I accentuated on doing Backups. In any case of a failure, you can revert the
version and restore the database.

Make sure you did the database backup! Apply:
`microk8s.kubectl apply -k ./` or
`microk8s.kubectl apply -f mysql-statefulset.yml`

So, we've been through setting exact services versions, and we did look into
how to handle upgrades. We discovered how to backup the database and we also
discovered where are our WordPress files stored in the default Storage addon.

It is time now, to discover how to handle high availability mode, with
multiple cluster nodes, aka multiple virtual cloud instances. It will force us
in setting up a more complex storage solution, make the database service be able
to move from node to node and similar for WordPress.

It's also fun, right?
